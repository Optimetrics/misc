#!/usr/bin/env python

import os, sys, getopt, urllib2, daemon, datetime, signal, pwd, pickle
from time import sleep
import MySQLdb as mdb
import json

version = "0.1.0"
cfg = { 'debug':False, 'log':sys.argv[0]+'.log', 'pid':sys.argv[0]+'.pid', 'poll':60, 
	'minconfirm': 2, 'maxconfirm': 6, 'confirmbreak': 0.1, 'block':210000 }
	
dbuser = 'your-user'
dbpwd = 'your-pwd'
dbname = 'your-db'
	
def main():
	loadcfg()
	if 'user' in cfg:
		print logts(),"Running as:",cfg['user']
		uid = pwd.getpwnam(cfg['user']).pw_uid
		os.setgid(uid)
		os.setuid(uid)
	if cfg['debug']:
		run()
	else:
		with daemon.DaemonContext(working_directory='/home/%s/'%cfg['user'],stdout=open(cfg['log'],'a'),stderr=open(cfg['log'],'a'),
			signal_map={signal.SIGTERM:sigterm}):
			run()

def run():
	print logts(), "Started pid:", os.getpid()
	with file(cfg['pid'],'w') as f: f.write(str(os.getpid()))
	while 1:
		try:
			latest = int(urllib2.urlopen("http://blockchain.info/q/getblockcount").read())
		except Exception as err:
			print logts(), "Error getting block count", err
		else:
			if (latest - cfg['maxconfirm']) > cfg['block']:
				print logts(), "Block %s All" % cfg['block']
				CheckBlock(cfg['block'])
				cfg['block'] += 1
			elif (latest - cfg['minconfirm']) >= cfg['block']:
				print logts(), "Block %s < %s,  %s All" % (cfg['block'], cfg['confirmbreak'], latest - cfg['maxconfirm'])
				CheckBlock(latest - cfg['maxconfirm'])
				CheckBlock(cfg['block'], cfg['confirmbreak'])
				cfg['block'] += 1
			savecfg()
		sys.stdout.flush()
		sleep(cfg['poll'])
		
def CheckBlock(height, limit=None):				
	try:
		data = json.load(urllib2.urlopen("http://blockchain.info/block-height/%s?format=json" % height))
		#data = json.load(open('test-block.json', 'r'))
		for block in data['blocks']:
			if block['main_chain']:
				Check4Pmts(block, limit)
	except Exception, err:
		print logts(), "Error getting block %s" % cfg['block'], err

def Check4Pmts(block, limit):
	global dbuser, dbpwd, dbname
	db = mdb.connect('localhost', dbuser, dbpwd, dbname)
	cur = db.cursor()
	for tx in block['tx']:
		for pmt in tx['out']:
			if limit == None or float(pmt['value'])/100000000 <= limit:
				cur.execute("select id from users where address=%s limit 1;", pmt['addr'])
				if cur.rowcount == 1:
					kid, = cur.fetchone()
					cur.execute("select id from pmts where trxhash=%s limit 1;", tx['hash'])
					if cur.rowcount == 0:
						print "Posted:", pmt['addr'], float(pmt['value'])/100000000
						cur.execute("insert into pmts (uid,trxhash,blockidx,amount,received) values (%s,%s,%s,%s,now());", 
							(kid, tx['hash'], block['block_index'], pmt['value']/100))
						cur.execute("update users set balance=balance+%s where id=%s;", (pmt['value']/100, kid))
						UpdateJobStatus(cur, kid)
	cur.close()
	db.close()
	
def UpdateJobStatus(cur, kid):
	cur.execute("select balance from users where id=%s;", kid)
	balance, = cur.fetchone()
	cur.execute("select id,fee from jobs where uid=%s and status<3 order by status desc,id desc;", kid)
	if cur.rowcount > 0:
		jobs = cur.fetchall()
		for job in jobs:
			jid,fee = job
			if fee*1000 <= balance:
				balance -= fee*1000
				cur.execute("update jobs set status=1 where id=%s and status=0;", jid)
		
def loadcfg():
	global cfg
	try:
		with open(sys.argv[0]+'.cfg') as f:
			cfg = pickle.load(f)
	except IOError:
		print logts(),'No cfg file.\n',
	finally:
		options()

def savecfg():
	try:
		with open(sys.argv[0]+'.cfg', 'w') as f:
			pickle.dump(cfg, f)
	except IOError:
		print logts(),'Cannot save cfg file'

def options():
	try:                                
		opts,args = getopt.getopt(sys.argv[1:], "hvb:", ["help", "version", "block=" ])
	except getopt.GetoptError:
		usage()
	for opt,arg in opts:
		if opt in ("-h", "--help"):
			usage()
		elif opt in ("-v", "--version"):
			sys.exit('Version: '+version)
		elif opt in ("-b", "--block"):
			cfg['block'] = int(arg)			
		elif opt in ("-p", "--poll"):
			cfg['poll'] = int(arg)
			
def usage():
	print "Command options are:\n-h,--help\tShow this help info\n-v,--version\tShow version info\n"
	print "-b,--block\tStart at block#\n-p, --poll Blockchain poll time in seconds\n"
	sys.exit(2)	
						
def sigterm(signum, frame):
	print "%s SIGTERM - Shutting down" % logts()
	os.unlink(cfg['pid'])
	sys.exit()

def logts():
	return datetime.datetime.now().strftime('%d-%m-%Y %H:%M:%S')
								
if __name__ == '__main__':
	main()
